---
isDraft: false
icon:
  name: material-symbols:integration-instructions-outline-rounded
  title: Programming Document Symbol
subHeadline: Let's solve FizzBuzz! Detailed problem-solving process
headline: Let's solve FizzBuzz! Detailed problem-solving process
excerpt: This time I will describe how to solve the problem by breaking down the solution step by step. It covers everything from basic solutions to separating data from logic, maintaining immutability, edge cases, and documentation. Print the numbers from 1 to 100; if the number is a multiple of 3, print Fizz; if the number is a multiple of 5, print Buzz; if the number is a common multiple of 3 and 5, print FizzBuzz.
category: Implementation
tags:
  - Beginner
publishDate: 2024-09-01
lastModifiedDate: 2024-09-23
---

## Introduction

FizzBuzz is probably one of the most well-known programming problems, and its question goes like this:

- Print the numbers from `1` to `100`
  - If the number is a multiple of `3`, print `Fizz`
  - If the number is a multiple of `5`, print `Buzz`
  - If the number is a common multiple of `3` and `5`, print `FizzBuzz`

## Solution

### Basic Solution

The most straightforward solution is to create a function that prints the numbers from `1` to `100`, and based on the rules, determines whether to print `Fizz`, `Buzz`, or `FizzBuzz`. However, this approach clearly hard-codes all the values in the program, making it inflexible if conditions need to be expanded in the future.

```js
function fizzBuzz(max) {
  for (let i = 1; i <= max; i++) {
    if (i % 3 === 0 && i % 5 === 0) {
      console.log('FizzBuzz');
    } else if (i % 3 === 0) {
      console.log('Fizz');
    } else if (i % 5 === 0) {
      console.log('Buzz');
    } else {
      console.log(i);
    }
  }
}

fizzBuzz(100);
```

### Separating Data from Logic

Since we can expect the rules to be `some number` prints `some result`, perhaps we can use an object to record these key-value structures:

```js
function fizzBuzz(max) {
  const map = {
    3: 'Fizz',
    5: 'Buzz',
    15: 'FizzBuzz',
  };

  for (let i = 1; i <= max; i++) {
    if (i % Object.keys(map)[0] === 0 && i % Object.keys(map)[1] === 0) {
      console.log(Object.values(map)[2]);
    } else if (i % Object.keys(map)[0] === 0) {
      console.log(Object.values(map)[0]);
    } else if (i % Object.keys(map)[1] === 0) {
      console.log(Object.values(map)[1]);
    } else {
      console.log(i);
    }
  }
}
```

The data has been separated, but the logic still relies on specific contents in the `map` object. Let's write a loop to automatically extract the contents of the `map` object, letting data drive the logic:

```js
function fizzBuzz(max) {
  const map = {
    3: 'Fizz',
    5: 'Buzz',
  };

  for (let i = 1; i <= max; i++) {
    let output = '';
    for (const key in map) {
      if (i % key === 0) {
        output += map[key];
      }
    }
    console.log(output || i);
  }
}
```

### Maintaining Immutability

In the solutions above, it's noticeable that two variables, `i` and `output`, have been defined and their contents continuously change throughout the program. **In some programming styles, this practice is regarded as something to avoid.** We can try to avoid rewriting variables and instead adopt [pure functions](https://www.webdong.dev/post/why-pure-function/).

```js
numberReplacer(100, {
  3: 'Fizz',
  5: 'Buzz',
}).forEach((value) => console.log(value));

function numberReplacer(max, replacementMap) {
  return Array.from({ length: max }, (_, index) => {
    const currentNumber = index + 1;
    const replacement = Object.entries(replacementMap).reduce(
      (acc, [divisor, replaceWord]) => (currentNumber % divisor === 0 ? acc + replaceWord : acc),
      '',
    );
    return replacement || currentNumber;
  });
}
```

### Completing Documentation and Checking Edge Cases

JavaScript is a dynamically typed language, so others using this function may not be clear about the specific parameter requirements. Here we complete the documentation using JSDoc and could also consider using TypeScript to check types or perform checks at runtime:

```js
/**
 * Generates an array, replacing the numbers from 1 to max with specified strings
 *
 * @param {number} max - The maximum number
 * @param {Object<number, string>} replacementMap - key is the divisor, value is the replacement string
 * @returns {Array<string | number>} - The replaced values
 * @throws {TypeError} if max is not a positive integer
 * @throws {TypeError} if replacementMap is not a non-empty object
 * @throws {TypeError} if keys in replacementMap are not positive integers
 * @example
 * numberReplacer(15, { 3: 'Fizz', 5: 'Buzz' });
 * // Returns [1, 2, 'Fizz', 4, 'Buzz', 'Fizz', 7, 8, 'Fizz', 'Buzz', 11, 'Fizz', 13, 14, 'FizzBuzz']
 */
function numberReplacer(max, replacementMap) {
  if (!Number.isInteger(max) || max <= 0) {
    throw new TypeError('max must be a positive integer');
  }

  if (typeof replacementMap !== 'object' || replacementMap === null) {
    throw new TypeError('replacementMap must be a non-empty object');
  }

  return Array.from({ length: max }, (_, index) => {
    const currentNumber = index + 1;
    const replacement = Object.entries(replacementMap).reduce((acc, [divisor, replaceWord]) => {
      const numDivisor = Number(divisor);
      if (!Number.isInteger(numDivisor) || numDivisor <= 0) {
        throw new TypeError('keys in replacementMap must be positive integers');
      }
      return currentNumber % numDivisor === 0 ? acc + replaceWord : acc;
    }, '');
    return replacement || currentNumber;
  });
}

try {
  numberReplacer(100, {
    3: 'Fizz',
    5: 'Buzz',
  }).forEach((value) => console.log(value));
} catch (error) {
  console.error(error.message);
}
```

### Simplifying `numberReplacer` with Partial Application

You might be thinking: Oh my! Why do we have to calculate just to print `FizzBuzz` every time through `numberReplacer`? Is there a way to simply create a function that just takes the maximum value like before? Letâ€™s use a partial application function to create an abstraction for simplification:

```js
const createFizzBuzz = (max) => {
  return numberReplacer(max, {
    3: 'Fizz',
    5: 'Buzz',
  });
};
const fizzBuzz100 = createFizzBuzz(100);
fizzBuzz100.forEach((value) => console.log(value));

const fizzBuzz15 = createFizzBuzz(15);
fizzBuzz15.forEach((value) => console.log(value));
```

Throughout this problem-solving process, I adhered to the [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle and continuously refactored to improve the readability and maintainability of the code, but it is also worth considering whether it is really necessary to create more abstractions. Premature optimization is the root of all evil; perhaps [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it).

## Further Reading

- [FizzBuzz: One Simple Interview Question - Tom Scott](https://www.youtube.com/watch?v=QPZ0pIK_wsc)